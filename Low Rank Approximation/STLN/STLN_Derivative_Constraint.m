function [fx_output,gx_output] = STLN_Derivative_Constraint(fx,t)
% Given the polynomial f(x) and the degree of the GCD of f(x) and its
% derivative. Calculate the low rank approximation of the Sylvester
% subresultant matrix S_{t}(f,f')

global MAX_ERROR_SNTLN 
global MAX_ITE_SNTLN


% Get degree of polynomial f(x)
m = GetDegree(fx);

% Get the derivative of f(x)
gx = Differentiate(fx);
n = m -1 ;

% Build the Sylvester matrix
C1 = BuildT1(fx,n-t);
C2 = BuildT1(gx,m-t);
St = [C1 C2];

% Get the index of the optimal colummn for removal
[~,colIndex] = GetMinDistance(St);

% Get Ak
At = St;
At(:,colIndex) = [];
ct = St(:,colIndex);

% Initialise the matrix of perturbations E_t
Et = zeros(size(At));

% Initialise the vector h_{t} 
ht = zeros(size(ct));

% Build the matrix P
Pt = BuildP(colIndex,m,t);


% Initalise the matrix z of structured perturbations to f(x)
% delta_z = zeros(m+1,1);
% delta_x = zeros(2*m-2*t+1,1);

% Build the matrix D
D = ...
    [
    m-t             zeros(1,m);
    zeros(m,1)    (2*m-t*t+1).*eye(m);
    ];

% Build the matrix Y_{t}
x_ls = SolveAx_b(At,ct);
x = [x_ls(1:colIndex-1) ;0; x_ls(colIndex:end)];
Yt = BuildY(x,m,t);


% Build the matrix E from the minimsation problem. Minimise Ew-p subject to
% Cw = q.
E = [D zeros(m+1,2*m-2*t+1)];

% Get the residual vector
res_vec = (ct+ht) - (At*x_ls);

% Initialise iteration number
ite = 1;
% Get termination criterion - Set to the norm of the residual vector
condition(ite) = norm(res_vec) ./ norm(ct);

% Initialise p vector
p = zeros(3*m-2*t+1,1);

% Initialise z vector of perturbations to f
z = zeros(m+1,1);

%H_z = Pt - Yt
%H_x = At - Et

H_z = Yt - Pt;
H_x = At + Et;
C = [H_z H_x];

% Define the starting vector for the iterations for the LSE problem.
start_point     =   ...
    [
    z;
    x_ls;
    ];

yy              =   start_point;


while condition(ite) > MAX_ERROR_SNTLN && ite < MAX_ITE_SNTLN
    
    
    
    y = LSE(E,p,C,res_vec);
    delta_z = y(1:m+1,1);
    delta_x = y(m+2:end,1);
    
    yy = yy + y;
    
    % (f) set x:=x+\delta x and z:= z+\delta_z
    % Update z
    z = z + delta_z;
    
    % Update x
    x_ls = x_ls + delta_x;
    
    
    % (g) Update E_{t} and h_{t} from z, and Yk from x
    
    % % Build new Et
    zg = Differentiate(z);
    
    % Build the matrix E_{t}
    E1 = BuildT1(z,m-1-t);
    E2 = BuildT1(zg,m-t);
    Bt = [E1 E2];
    
    Et = Bt;
    Et(:,colIndex) = [];
    ht = Bt(:,colIndex);

    % % Build new Yt
    x_ls = SolveAx_b(At+Et,ct+ht);
    x= [x_ls(1:colIndex-1) ;0; x_ls(colIndex:end)];
    Yt = BuildY(x,m,t);
    
    res_vec = (ct+ht) - ((At+Et)*x_ls);
    
    % Update the matrix C
    H_z = Yt - Pt;
    H_x = At + Et;
    C = [H_z H_x];
    
    
    rk = res_vec;
    
    % Update fnew - used in LSE Problem.
    p = -(yy-start_point);
    
    ite = ite + 1;
    condition(ite) = norm(rk) ./ norm(ct+ht) ;
    
    
    
end

figure('name','STLN - Residuals')
hold on
plot(log10(condition));
hold off

fprintf('Required number of iterations : %i \n',ite)

% Output coefficients of f(x)
display(fx);

% Output coefficients of f(x) + delta f(x)
fx_output = fx + z;
gx_output = gx + zg;

end




function Pk = BuildP(colIndex,m,t)
% Build the matrix P such that a column in Ek, specified by the column index
% is generated by the matrix vector product P*z, or a column of Ak is given
% by P*z

if colIndex <= m-t
    i = colIndex;
    mat = ...
        [
        zeros(i-1,m+1);
        diag(ones(m+1,1));
        zeros(m-t-i,m+1);
        ];
    Pk = mat;
    
elseif colIndex > m-t && colIndex <= 2*m-2*t+1
    i = colIndex - (m-t);
    mat = ...
        [
        zeros(i-1,m+1);
        zeros(m,1) diag(1:1:m);
        zeros(m-t-i+1,m+1);
        ];
    % Remove the first row
    Pk = mat;
end

end


function Y = BuildY(x,m,t)

% The first (m-t) coefficients are for the first matrix
xa = x(1:m-t);
xb = x(m-t+1:end);

mat1 = BuildT1(xa,m);
mat2 = BuildT1(xb,m-1);

mat2 =  [zeros(2*m-t,1) mat2 ] * diag(0:1:m) ;

Y = mat1 + mat2;

end